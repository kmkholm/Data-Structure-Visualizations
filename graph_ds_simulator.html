<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Data Structures - Interactive Learning Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .header h2 {
            color: #34495e;
            font-size: 1.2rem;
            font-weight: normal;
        }

        .container {
            display: flex;
            height: calc(100vh - 120px);
            gap: 20px;
            padding: 20px;
        }

        .sidebar {
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .graph-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .graph-type-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 12px;
        }

        .graph-type-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .graph-type-btn.active {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            width: 60px;
        }

        input.wide {
            width: 80px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #27ae60, #2ecc71);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 12px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
        }

        .delete-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .delete-btn:hover {
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .algorithm-btn {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .algorithm-btn:hover {
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .clear-btn {
            background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #ecf0f1;
            padding: 10px;
            border-radius: 8px;
        }

        .speed-slider {
            width: 120px;
        }

        .canvas-container {
            flex: 1;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #f8f9fa;
            position: relative;
            overflow: hidden;
        }

        #graphCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graphCanvas:active {
            cursor: grabbing;
        }

        .info-panel {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-panel h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .complexity-info {
            background: #fff;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #3498db;
        }

        .theory-section {
            margin-bottom: 20px;
        }

        .theory-section h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #3498db;
        }

        .code-snippet {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            overflow-x: auto;
            font-size: 12px;
        }

        .algorithm-result {
            background: #e8f5e8;
            border: 1px solid #27ae60;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .node-info {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        .mode-indicator {
            background: #3498db;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .path-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        @keyframes nodeHighlight {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .highlight-node {
            animation: nodeHighlight 0.5s ease-in-out;
        }

        .adjacency-matrix {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 10px;
            max-height: 150px;
            overflow: auto;
        }

        .matrix-cell {
            display: inline-block;
            width: 25px;
            text-align: center;
            border: 1px solid #eee;
            padding: 2px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Graph Data Structures - Interactive Learning Platform</h1>
        <h2>Created by Dr. Mohammed Tawfik - Advanced C++ Data Structures Course</h2>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="theory-section">
                <h4>Graph Theory</h4>
                <p><strong>Graphs</strong> are collections of vertices (nodes) connected by edges. They model relationships and connections in various real-world scenarios.</p>
                
                <div class="complexity-info">
                    <strong>Algorithm Complexities:</strong><br>
                    • BFS/DFS: O(V + E)<br>
                    • Dijkstra: O(V²) or O(E log V)<br>
                    • Floyd-Warshall: O(V³)<br>
                    • Kruskal/Prim: O(E log E)
                </div>
            </div>

            <div class="theory-section">
                <h4>C++ Graph Representation</h4>
                <div class="code-snippet">
// Adjacency List
class Graph {
    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj;
    bool directed;
public:
    Graph(int V, bool dir = false) : 
        adj(V), directed(dir) {}
    
    void addEdge(int u, int v, int w = 1) {
        adj[u].push_back({v, w});
        if (!directed) 
            adj[v].push_back({u, w});
    }
};</div>
            </div>

            <div class="theory-section">
                <h4>DFS Implementation</h4>
                <div class="code-snippet">
void DFS(int v, vector&lt;bool&gt;&amp; visited) {
    visited[v] = true;
    cout &lt;&lt; v &lt;&lt; " ";
    
    for (auto&amp; edge : adj[v]) {
        if (!visited[edge.first]) {
            DFS(edge.first, visited);
        }
    }
}</div>
            </div>

            <div class="info-panel">
                <h3>Current Graph Info</h3>
                <div id="graphStats">
                    <p>Vertices: <span id="vertexCount">0</span></p>
                    <p>Edges: <span id="edgeCount">0</span></p>
                    <p>Density: <span id="graphDensity">0%</span></p>
                    <p>Type: <span id="currentGraphType">Undirected</span></p>
                </div>
            </div>

            <div class="speed-control">
                <label for="speedSlider">Speed:</label>
                <input type="range" id="speedSlider" class="speed-slider" min="1" max="10" value="5">
                <span id="speedValue">5x</span>
            </div>

            <div class="algorithm-result" id="algorithmResult" style="display: none;">
                <strong>Algorithm Result:</strong><br>
                <span id="algorithmOutput"></span>
            </div>

            <div class="path-info" id="pathInfo" style="display: none;">
                <strong>Path Information:</strong><br>
                <span id="pathOutput"></span>
            </div>

            <div class="adjacency-matrix" id="adjacencyMatrix" style="display: none;">
                <strong>Adjacency Matrix:</strong><br>
                <div id="matrixContent"></div>
            </div>
        </div>

        <div class="main-content">
            <div class="graph-type-selector">
                <button class="graph-type-btn active" data-type="undirected">Undirected</button>
                <button class="graph-type-btn" data-type="directed">Directed</button>
                <button class="graph-type-btn" data-type="weighted">Weighted</button>
                <button class="graph-type-btn" data-type="complete">Complete</button>
            </div>

            <div class="controls">
                <div class="mode-indicator" id="modeIndicator">Add Nodes Mode</div>
                
                <div class="input-group">
                    <button onclick="setMode('addNode')">Add Nodes</button>
                    <button onclick="setMode('addEdge')">Add Edges</button>
                    <button onclick="setMode('deleteNode')">Delete Nodes</button>
                    <button onclick="setMode('deleteEdge')">Delete Edges</button>
                </div>

                <div class="input-group">
                    <label>Weight:</label>
                    <input type="number" id="edgeWeight" value="1" min="1" max="99" class="wide">
                </div>
            </div>

            <div class="controls">
                <div class="input-group">
                    <button class="algorithm-btn" onclick="runAlgorithm('bfs')">BFS</button>
                    <button class="algorithm-btn" onclick="runAlgorithm('dfs')">DFS</button>
                    <button class="algorithm-btn" onclick="runAlgorithm('dijkstra')">Dijkstra</button>
                    <button class="algorithm-btn" onclick="runAlgorithm('kruskal')">Kruskal MST</button>
                </div>

                <div class="input-group">
                    <label>Start:</label>
                    <input type="number" id="startNode" value="0" min="0">
                    <label>End:</label>
                    <input type="number" id="endNode" value="1" min="0">
                </div>

                <div class="input-group">
                    <button onclick="generateRandomGraph()">Random Graph</button>
                    <button onclick="showAdjacencyMatrix()">Show Matrix</button>
                    <button class="clear-btn" onclick="clearGraph()">Clear Graph</button>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #3498db;"></div>
                    <span>Normal Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span>Start Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #27ae60;"></div>
                    <span>End Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span>Visiting Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9b59b6;"></div>
                    <span>Visited Node</span>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
                <div class="node-info" id="nodeInfo" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        class GraphNode {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = 25;
                this.color = '#3498db';
                this.textColor = 'white';
                this.isSelected = false;
                this.state = 'normal'; // normal, visiting, visited, start, end
            }
        }

        class GraphEdge {
            constructor(from, to, weight = 1) {
                this.from = from;
                this.to = to;
                this.weight = weight;
                this.color = '#34495e';
                this.isHighlighted = false;
            }
        }

        class GraphVisualizer {
            constructor() {
                this.canvas = document.getElementById('graphCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = new Map();
                this.edges = [];
                this.graphType = 'undirected';
                this.mode = 'addNode';
                this.selectedNode = null;
                this.nodeIdCounter = 0;
                this.animationSpeed = 5;
                this.isAnimating = false;
                
                this.setupCanvas();
                this.setupEventListeners();
            }

            setupCanvas() {
                const resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    this.canvas.width = container.offsetWidth;
                    this.canvas.height = container.offsetHeight;
                    this.draw();
                };
                
                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();
            }

            setupEventListeners() {
                // Graph type selection
                document.querySelectorAll('.graph-type-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.graph-type-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.graphType = e.target.dataset.type;
                        document.getElementById('currentGraphType').textContent = this.getGraphTypeName();
                        if (this.graphType === 'complete') {
                            this.generateCompleteGraph();
                        }
                    });
                });

                // Canvas events
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));

                // Speed control
                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                    document.getElementById('speedValue').textContent = `${this.animationSpeed}x`;
                });
            }

            getGraphTypeName() {
                const names = {
                    'undirected': 'Undirected',
                    'directed': 'Directed',
                    'weighted': 'Weighted',
                    'complete': 'Complete'
                };
                return names[this.graphType];
            }

            setMode(newMode) {
                this.mode = newMode;
                this.selectedNode = null;
                
                const modeNames = {
                    'addNode': 'Add Nodes Mode',
                    'addEdge': 'Add Edges Mode',
                    'deleteNode': 'Delete Nodes Mode',
                    'deleteEdge': 'Delete Edges Mode'
                };
                
                document.getElementById('modeIndicator').textContent = modeNames[newMode];
                this.draw();
            }

            handleCanvasClick(e) {
                if (this.isAnimating) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const clickedNode = this.findNodeAt(x, y);

                switch (this.mode) {
                    case 'addNode':
                        if (!clickedNode) {
                            this.addNode(x, y);
                        }
                        break;

                    case 'addEdge':
                        if (clickedNode) {
                            if (!this.selectedNode) {
                                this.selectedNode = clickedNode;
                                clickedNode.isSelected = true;
                            } else if (this.selectedNode !== clickedNode) {
                                this.addEdge(this.selectedNode, clickedNode);
                                this.selectedNode.isSelected = false;
                                this.selectedNode = null;
                            }
                        }
                        break;

                    case 'deleteNode':
                        if (clickedNode) {
                            this.deleteNode(clickedNode);
                        }
                        break;

                    case 'deleteEdge':
                        if (clickedNode) {
                            if (!this.selectedNode) {
                                this.selectedNode = clickedNode;
                                clickedNode.isSelected = true;
                            } else if (this.selectedNode !== clickedNode) {
                                this.deleteEdge(this.selectedNode, clickedNode);
                                this.selectedNode.isSelected = false;
                                this.selectedNode = null;
                            }
                        }
                        break;
                }

                this.draw();
            }

            addNode(x, y) {
                const node = new GraphNode(this.nodeIdCounter++, x, y);
                this.nodes.set(node.id, node);
                this.updateStats();
            }

            addEdge(fromNode, toNode) {
                // Check if edge already exists
                const edgeExists = this.edges.some(edge => 
                    (edge.from === fromNode && edge.to === toNode) ||
                    (!this.isDirected() && edge.from === toNode && edge.to === fromNode)
                );

                if (!edgeExists) {
                    const weight = this.isWeighted() ? parseInt(document.getElementById('edgeWeight').value) || 1 : 1;
                    this.edges.push(new GraphEdge(fromNode, toNode, weight));
                    this.updateStats();
                }
            }

            deleteNode(node) {
                this.nodes.delete(node.id);
                this.edges = this.edges.filter(edge => edge.from !== node && edge.to !== node);
                this.updateStats();
            }

            deleteEdge(fromNode, toNode) {
                this.edges = this.edges.filter(edge => 
                    !(edge.from === fromNode && edge.to === toNode) &&
                    !(!this.isDirected() && edge.from === toNode && edge.to === fromNode)
                );
                this.updateStats();
            }

            isDirected() {
                return this.graphType === 'directed';
            }

            isWeighted() {
                return this.graphType === 'weighted';
            }

            findNodeAt(x, y) {
                for (let node of this.nodes.values()) {
                    const distance = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                    if (distance <= node.radius) {
                        return node;
                    }
                }
                return null;
            }

            generateRandomGraph() {
                this.clearGraph();
                
                const nodeCount = 6 + Math.floor(Math.random() * 6);
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 100;

                // Create nodes in a circle
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (2 * Math.PI * i) / nodeCount;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    this.addNode(x, y);
                }

                // Add random edges
                const edgeCount = nodeCount + Math.floor(Math.random() * nodeCount);
                for (let i = 0; i < edgeCount; i++) {
                    const nodes = Array.from(this.nodes.values());
                    const from = nodes[Math.floor(Math.random() * nodes.length)];
                    const to = nodes[Math.floor(Math.random() * nodes.length)];
                    
                    if (from !== to) {
                        this.selectedNode = from;
                        this.addEdge(from, to);
                    }
                }

                this.selectedNode = null;
                this.draw();
            }

            generateCompleteGraph() {
                this.clearGraph();
                
                const nodeCount = 5;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 100;

                // Create nodes in a circle
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (2 * Math.PI * i) / nodeCount;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    this.addNode(x, y);
                }

                // Connect all nodes to all other nodes
                const nodes = Array.from(this.nodes.values());
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        this.addEdge(nodes[i], nodes[j]);
                    }
                }

                this.draw();
            }

            clearGraph() {
                this.nodes.clear();
                this.edges = [];
                this.selectedNode = null;
                this.nodeIdCounter = 0;
                this.updateStats();
                this.draw();
                document.getElementById('algorithmResult').style.display = 'none';
                document.getElementById('pathInfo').style.display = 'none';
                document.getElementById('adjacencyMatrix').style.display = 'none';
            }

            async runAlgorithm(algorithm) {
                if (this.isAnimating) return;
                
                this.resetNodeStates();
                
                const startNodeId = parseInt(document.getElementById('startNode').value);
                const endNodeId = parseInt(document.getElementById('endNode').value);
                
                const startNode = this.nodes.get(startNodeId);
                const endNode = this.nodes.get(endNodeId);

                if (!startNode) {
                    alert('Start node not found!');
                    return;
                }

                switch (algorithm) {
                    case 'bfs':
                        await this.runBFS(startNode);
                        break;
                    case 'dfs':
                        await this.runDFS(startNode);
                        break;
                    case 'dijkstra':
                        if (!endNode) {
                            alert('End node required for Dijkstra!');
                            return;
                        }
                        await this.runDijkstra(startNode, endNode);
                        break;
                    case 'kruskal':
                        await this.runKruskal();
                        break;
                }
            }

            async runBFS(startNode) {
                this.isAnimating = true;
                const visited = new Set();
                const queue = [startNode];
                const result = [];

                startNode.state = 'start';
                this.draw();
                await this.sleep(1000 / this.animationSpeed);

                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    if (visited.has(current.id)) continue;
                    
                    visited.add(current.id);
                    result.push(current.id);
                    
                    current.state = 'visiting';
                    this.draw();
                    await this.sleep(800 / this.animationSpeed);
                    
                    // Find adjacent nodes
                    const adjacent = this.getAdjacentNodes(current);
                    for (let neighbor of adjacent) {
                        if (!visited.has(neighbor.id)) {
                            queue.push(neighbor);
                        }
                    }
                    
                    current.state = 'visited';
                    this.draw();
                    await this.sleep(400 / this.animationSpeed);
                }

                this.showAlgorithmResult('BFS Traversal', result.join(' → '));
                this.isAnimating = false;
            }

            async runDFS(startNode) {
                this.isAnimating = true;
                const visited = new Set();
                const result = [];

                await this.dfsRecursive(startNode, visited, result);
                
                this.showAlgorithmResult('DFS Traversal', result.join(' → '));
                this.isAnimating = false;
            }

            async dfsRecursive(node, visited, result) {
                visited.add(node.id);
                result.push(node.id);
                
                node.state = result.length === 1 ? 'start' : 'visiting';
                this.draw();
                await this.sleep(800 / this.animationSpeed);
                
                const adjacent = this.getAdjacentNodes(node);
                for (let neighbor of adjacent) {
                    if (!visited.has(neighbor.id)) {
                        await this.dfsRecursive(neighbor, visited, result);
                    }
                }
                
                node.state = 'visited';
                this.draw();
                await this.sleep(400 / this.animationSpeed);
            }

            async runDijkstra(startNode, endNode) {
                this.isAnimating = true;
                const distances = new Map();
                const previous = new Map();
                const unvisited = new Set();
                
                // Initialize distances
                for (let node of this.nodes.values()) {
                    distances.set(node.id, Infinity);
                    unvisited.add(node.id);
                }
                distances.set(startNode.id, 0);
                
                startNode.state = 'start';
                endNode.state = 'end';
                this.draw();
                await this.sleep(1000 / this.animationSpeed);

                while (unvisited.size > 0) {
                    // Find unvisited node with minimum distance
                    let current = null;
                    let minDistance = Infinity;
                    
                    for (let nodeId of unvisited) {
                        if (distances.get(nodeId) < minDistance) {
                            minDistance = distances.get(nodeId);
                            current = this.nodes.get(nodeId);
                        }
                    }
                    
                    if (!current || minDistance === Infinity) break;
                    
                    unvisited.delete(current.id);
                    
                    if (current !== startNode && current !== endNode) {
                        current.state = 'visiting';
                    }
                    this.draw();
                    await this.sleep(800 / this.animationSpeed);
                    
                    // Update distances to neighbors
                    const adjacent = this.getAdjacentNodes(current);
                    for (let neighbor of adjacent) {
                        if (unvisited.has(neighbor.id)) {
                            const edge = this.getEdge(current, neighbor);
                            const alt = distances.get(current.id) + (edge ? edge.weight : 1);
                            
                            if (alt < distances.get(neighbor.id)) {
                                distances.set(neighbor.id, alt);
                                previous.set(neighbor.id, current.id);
                            }
                        }
                    }
                    
                    if (current !== startNode && current !== endNode) {
                        current.state = 'visited';
                    }
                    this.draw();
                    await this.sleep(400 / this.animationSpeed);
                }

                // Reconstruct path
                const path = [];
                let current = endNode.id;
                while (current !== undefined) {
                    path.unshift(current);
                    current = previous.get(current);
                }

                this.highlightPath(path);
                this.showPathInfo(path, distances.get(endNode.id));
                this.isAnimating = false;
            }

            async runKruskal() {
                this.isAnimating = true;
                
                // Sort edges by weight
                const sortedEdges = [...this.edges].sort((a, b) => a.weight - b.weight);
                const mst = [];
                const parent = new Map();
                const rank = new Map();
                
                // Initialize union-find
                for (let node of this.nodes.values()) {
                    parent.set(node.id, node.id);
                    rank.set(node.id, 0);
                }
                
                const find = (x) => {
                    if (parent.get(x) !== x) {
                        parent.set(x, find(parent.get(x)));
                    }
                    return parent.get(x);
                };
                
                const union = (x, y) => {
                    const rootX = find(x);
                    const rootY = find(y);
                    
                    if (rootX !== rootY) {
                        if (rank.get(rootX) < rank.get(rootY)) {
                            parent.set(rootX, rootY);
                        } else if (rank.get(rootX) > rank.get(rootY)) {
                            parent.set(rootY, rootX);
                        } else {
                            parent.set(rootY, rootX);
                            rank.set(rootX, rank.get(rootX) + 1);
                        }
                        return true;
                    }
                    return false;
                };
                
                // Process edges
                for (let edge of sortedEdges) {
                    edge.isHighlighted = true;
                    this.draw();
                    await this.sleep(1000 / this.animationSpeed);
                    
                    if (union(edge.from.id, edge.to.id)) {
                        mst.push(edge);
                        edge.color = '#27ae60';
                    } else {
                        edge.color = '#e74c3c';
                    }
                    
                    this.draw();
                    await this.sleep(800 / this.animationSpeed);
                    edge.isHighlighted = false;
                }
                
                const totalWeight = mst.reduce((sum, edge) => sum + edge.weight, 0);
                this.showAlgorithmResult('Kruskal MST', `Edges: ${mst.length}, Total Weight: ${totalWeight}`);
                this.isAnimating = false;
            }

            getAdjacentNodes(node) {
                const adjacent = [];
                for (let edge of this.edges) {
                    if (edge.from === node) {
                        adjacent.push(edge.to);
                    } else if (!this.isDirected() && edge.to === node) {
                        adjacent.push(edge.from);
                    }
                }
                return adjacent;
            }

            getEdge(from, to) {
                return this.edges.find(edge => 
                    (edge.from === from && edge.to === to) ||
                    (!this.isDirected() && edge.from === to && edge.to === from)
                );
            }

            highlightPath(path) {
                for (let i = 0; i < path.length - 1; i++) {
                    const from = this.nodes.get(path[i]);
                    const to = this.nodes.get(path[i + 1]);
                    const edge = this.getEdge(from, to);
                    if (edge) {
                        edge.color = '#27ae60';
                        edge.isHighlighted = true;
                    }
                }
                this.draw();
            }

            showAlgorithmResult(title, result) {
                document.getElementById('algorithmResult').style.display = 'block';
                document.getElementById('algorithmOutput').innerHTML = `<strong>${title}:</strong><br>${result}`;
            }

            showPathInfo(path, distance) {
                document.getElementById('pathInfo').style.display = 'block';
                document.getElementById('pathOutput').innerHTML = 
                    `Path: ${path.join(' → ')}<br>Distance: ${distance === Infinity ? 'No path' : distance}`;
            }

            showAdjacencyMatrix() {
                const matrix = this.buildAdjacencyMatrix();
                const matrixDiv = document.getElementById('adjacencyMatrix');
                const contentDiv = document.getElementById('matrixContent');
                
                let html = '<div style="margin-bottom: 10px;">';
                
                // Header row
                html += '<div class="matrix-cell" style="font-weight: bold;"></div>';
                for (let node of this.nodes.values()) {
                    html += `<div class="matrix-cell" style="font-weight: bold;">${node.id}</div>`;
                }
                html += '</div>';
                
                // Matrix rows
                for (let i of this.nodes.keys()) {
                    html += '<div>';
                    html += `<div class="matrix-cell" style="font-weight: bold;">${i}</div>`;
                    for (let j of this.nodes.keys()) {
                        const weight = matrix.get(i)?.get(j) || 0;
                        html += `<div class="matrix-cell">${weight}</div>`;
                    }
                    html += '</div>';
                }
                
                contentDiv.innerHTML = html;
                matrixDiv.style.display = 'block';
            }

            buildAdjacencyMatrix() {
                const matrix = new Map();
                
                // Initialize matrix
                for (let i of this.nodes.keys()) {
                    matrix.set(i, new Map());
                    for (let j of this.nodes.keys()) {
                        matrix.get(i).set(j, 0);
                    }
                }
                
                // Fill matrix
                for (let edge of this.edges) {
                    matrix.get(edge.from.id).set(edge.to.id, edge.weight);
                    if (!this.isDirected()) {
                        matrix.get(edge.to.id).set(edge.from.id, edge.weight);
                    }
                }
                
                return matrix;
            }

            resetNodeStates() {
                for (let node of this.nodes.values()) {
                    node.state = 'normal';
                }
                for (let edge of this.edges) {
                    edge.color = '#34495e';
                    edge.isHighlighted = false;
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw edges
                for (let edge of this.edges) {
                    this.drawEdge(edge);
                }
                
                // Draw nodes
                for (let node of this.nodes.values()) {
                    this.drawNode(node);
                }
            }

            drawEdge(edge) {
                const from = edge.from;
                const to = edge.to;
                
                this.ctx.beginPath();
                this.ctx.moveTo(from.x, from.y);
                this.ctx.lineTo(to.x, to.y);
                
                this.ctx.strokeStyle = edge.color;
                this.ctx.lineWidth = edge.isHighlighted ? 4 : 2;
                this.ctx.stroke();
                
                // Draw arrow for directed graphs
                if (this.isDirected()) {
                    this.drawArrow(from, to);
                }
                
                // Draw weight
                if (this.isWeighted()) {
                    const midX = (from.x + to.x) / 2;
                    const midY = (from.y + to.y) / 2;
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillRect(midX - 10, midY - 10, 20, 20);
                    this.ctx.fillStyle = '#2c3e50';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(edge.weight, midX, midY);
                }
            }

            drawArrow(from, to) {
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                const arrowLength = 15;
                const arrowAngle = Math.PI / 6;
                
                const endX = to.x - to.radius * Math.cos(angle);
                const endY = to.y - to.radius * Math.sin(angle);
                
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - arrowLength * Math.cos(angle - arrowAngle),
                    endY - arrowLength * Math.sin(angle - arrowAngle)
                );
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - arrowLength * Math.cos(angle + arrowAngle),
                    endY - arrowLength * Math.sin(angle + arrowAngle)
                );
                this.ctx.stroke();
            }

            drawNode(node) {
                // Node circle
                this.ctx.beginPath();
                this.ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
                
                switch (node.state) {
                    case 'start':
                        this.ctx.fillStyle = '#e74c3c';
                        break;
                    case 'end':
                        this.ctx.fillStyle = '#27ae60';
                        break;
                    case 'visiting':
                        this.ctx.fillStyle = '#f39c12';
                        break;
                    case 'visited':
                        this.ctx.fillStyle = '#9b59b6';
                        break;
                    default:
                        this.ctx.fillStyle = node.isSelected ? '#e67e22' : '#3498db';
                }
                
                this.ctx.fill();
                this.ctx.strokeStyle = '#2c3e50';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
                
                // Node label
                this.ctx.fillStyle = 'white';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(node.id, node.x, node.y);
            }

            updateStats() {
                const vertexCount = this.nodes.size;
                const edgeCount = this.edges.length;
                const maxEdges = this.isDirected() ? 
                    vertexCount * (vertexCount - 1) : 
                    vertexCount * (vertexCount - 1) / 2;
                const density = maxEdges > 0 ? ((edgeCount / maxEdges) * 100).toFixed(1) : 0;
                
                document.getElementById('vertexCount').textContent = vertexCount;
                document.getElementById('edgeCount').textContent = edgeCount;
                document.getElementById('graphDensity').textContent = `${density}%`;
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const hoveredNode = this.findNodeAt(x, y);
                const nodeInfo = document.getElementById('nodeInfo');
                
                if (hoveredNode) {
                    nodeInfo.style.display = 'block';
                    nodeInfo.style.left = (e.clientX + 10) + 'px';
                    nodeInfo.style.top = (e.clientY - 30) + 'px';
                    
                    const adjacent = this.getAdjacentNodes(hoveredNode);
                    nodeInfo.textContent = `Node ${hoveredNode.id} - Degree: ${adjacent.length}`;
                } else {
                    nodeInfo.style.display = 'none';
                }
            }
        }

        // Global variables and functions
        let graphViz;

        function setMode(mode) {
            graphViz.setMode(mode);
        }

        function runAlgorithm(algorithm) {
            graphViz.runAlgorithm(algorithm);
        }

        function generateRandomGraph() {
            graphViz.generateRandomGraph();
        }

        function showAdjacencyMatrix() {
            graphViz.showAdjacencyMatrix();
        }

        function clearGraph() {
            graphViz.clearGraph();
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            graphViz = new GraphVisualizer();
        });
    </script>
</body>
</html>